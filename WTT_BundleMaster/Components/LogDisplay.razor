@inject LogService LogService
@using System.Collections.Specialized
@implements IDisposable

<MudPaper Class="pa-4" Style="height: 100%; display: flex; flex-direction: column; overflow: auto;">
    <div class="d-flex justify-space-between align-center mb-4">
        <MudText Typo="Typo.h6">Activity Log (@LogService.Logs.Count)</MudText>
        <MudButton OnClick="() => LogService.Clear()">Clear</MudButton>
    </div>

    <div style="overflow-y: auto; flex-grow: 1;">
        @foreach (var log in _displayedLogs)
        {
        <MudText Class="@GetLogClass(log.Level)" Typo="Typo.body2">
            [@log.Timestamp.ToString("HH:mm:ss")] @log.Message
        </MudText>
        }
    </div>
    
</MudPaper>

@code {
    private IEnumerable<LogEntry> _displayedLogs => LogService.Logs
        .Skip(Math.Max(0, LogService.Logs.Count - 50))
        .Reverse();

    private DateTime _lastUpdate = DateTime.MinValue;
    private Timer _updateTimer;
    private bool _needsUpdate = false;
    private void Logs_CollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
    {
        _needsUpdate = true;
        _updateTimer?.Dispose();
        _updateTimer = new Timer(_ =>
        {
            if (!_needsUpdate) return;
            _needsUpdate = false;
            InvokeAsync(StateHasChanged);
        }, null, 100, Timeout.Infinite);
    }

    protected override void OnInitialized()
    {
        LogService.Logs.CollectionChanged += Logs_CollectionChanged;
    }
    
    public void Dispose()
    {
        LogService.Logs.CollectionChanged -= Logs_CollectionChanged;
        _updateTimer?.Dispose();
        GC.SuppressFinalize(this);
    }
    

    private string GetLogClass(string level) => level switch
    {
        "warning" => "text-warning",
        "error" => "text-error",
        _ => "text-info"
    };
}